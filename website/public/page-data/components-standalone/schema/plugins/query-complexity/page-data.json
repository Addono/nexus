{"componentChunkName":"component---src-layouts-article-layout-tsx","path":"/components-standalone/schema/plugins/query-complexity","result":{"data":{"site":{"siteMetadata":{"docsLocation":"https://github.com/graphql-nexus/docs/tree/master/content"}},"mdx":{"fields":{"slug":"/06-components-standalone/01-schema/03-plugins/02-query-complexity"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Query Complexity\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"section\", null, mdx(\"h2\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"query-complexity\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#query-complexity\",\n    \"aria-label\": \"query complexity permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Query Complexity\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"A single GraphQL query can potentially generate a huge workload for a server, like thousands of database operations which can be used to cause DDoS attacks. In order to limit and keep track of what each GraphQL operation can do, the query complexity plugin allows defining field-level complexity values that works with the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/slicknode/graphql-query-complexity\"\n  }), \"graphql-query-complexity\"), \" library.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"To install, add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"queryComplexityPlugin\"), \" to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"makeSchema.plugins\"), \" array, along with any other plugins you'd like to include:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"import { makeSchema, queryComplexityPlugin } from '@nexus/schema'\\n\\nconst schema = makeSchema({\\n  // ... types, etc,\\n  plugins: [\\n    // ... other plugins\\n    queryComplexityPlugin(),\\n  ],\\n})\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The plugin will install a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"complexity\"), \" property on the output field config:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export const User = objectType({\\n  name: 'User',\\n  definition(t) {\\n    t.id('id', {\\n      complexity: 2,\\n    })\\n  },\\n})\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"And of course, integrate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-query-complexity\"), \" with your GraphQL server. You can setup with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"express-graphql\"), \" as in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/slicknode/graphql-query-complexity#usage-with-express-graphql\"\n  }), \"the library's example\"), \".\"), mdx(\"section\", {\n    parentName: \"section\"\n  }, mdx(\"h3\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"complexity-value\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#complexity-value\",\n    \"aria-label\": \"complexity value permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Complexity Value\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"There are two ways to define the complexity:\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A number\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A complexity estimator\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The easiest way to specify the complexity is to just provide a number, as in the example code above. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"complexity\"), \" property can be omitted if its value is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \", provided that you have a simple estimator of 1 when configuring \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-query-complexity\"), \" like below:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const complexity = getComplexity({\\n  // ... other configurations\\n  estimators: [\\n    // All undefined complexity values will fallback to 1\\n    simpleEstimator({ defaultComplexity: 1 }),\\n  ],\\n})\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Another way is with the complexity estimator, which is a function that returns a number, but also provides arguments to compute the final value. The query complexity plugin augments \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"graphql-query-complexity\"), \"'s default complexity estimator by providing its corresponding nexus types to ensure type-safety. No additional arguments are introduced so the function declaration is still syntactically equal.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Augmented complexity estimator function signature:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"type QueryComplexityEstimatorArgs<TypeName extends string, FieldName extends string> = {\\n  // The root type the field belongs too\\n  type: RootValue<TypeName>\\n\\n  // The GraphQLField that is being evaluated\\n  field: GraphQLField<RootValue<TypeName>, GetGen<'context'>, ArgsValue<TypeName, FieldName>>\\n\\n  // The input arguments of the field\\n  args: ArgsValue<TypeName, FieldName>\\n\\n  // The complexity of all child selections for that field\\n  childComplexity: number\\n}\\n\\ntype QueryComplexityEstimator = (options: QueryComplexityEstimatorArgs) => number | void\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"And you can use it like so:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export const users = queryField('users', {\\n  type: 'User',\\n  list: true,\\n  args: {\\n    count: intArg({ nullable: false }),\\n  },\\n  // This will calculate the complexity based on the count and child complexity.\\n  // This is useful to prevent clients from querying mass amount of data.\\n  complexity: ({ args, childComplexity }) => args.count * childComplexity,\\n  resolve: () => [{ id: '1' }],\\n})\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"For more info about how query complexity is computed, please visit \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/slicknode/graphql-query-complexity\"\n  }), \"graphql-query-complexity\"), \".\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","relativePath":"06-components-standalone/01-schema/03-plugins/02-query-complexity.mdx"},"tableOfContents":{"items":[{"url":"#query-complexity","title":"Query Complexity","items":[{"url":"#complexity-value","title":"Complexity Value"}]}]},"frontmatter":{"title":"Query Complexity","metaTitle":null,"metaDescription":null}}},"pageContext":{"id":"2cc0a334-2538-5bbd-8ceb-74313ce005fc","seoTitle":"Query Complexity","seoDescription":"Query Complexity"}}}