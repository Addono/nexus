{"expireTime":9007200846064555000,"key":"gatsby-plugin-mdx-entire-payload-bc08b124a35d2f18ef3f8ad44a4c5c00-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"\\n# ","position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":1,"column":5,"offset":4},"indent":[]}},{"type":"inlineCode","value":"@nexus/schema","position":{"start":{"line":1,"column":5,"offset":4},"end":{"line":1,"column":20,"offset":19},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":1,"column":20,"offset":19},"indent":[]}},{"type":"code","lang":"cli","meta":null,"value":"npm install @nexus/schema","position":{"start":{"line":3,"column":1,"offset":21},"end":{"line":5,"column":4,"offset":57},"indent":[1,1]}},{"type":"heading","depth":4,"children":[{"type":"text","value":"Why Nexus? {docsify-ignore}","position":{"start":{"line":7,"column":6,"offset":64},"end":{"line":7,"column":33,"offset":91},"indent":[]}}],"position":{"start":{"line":7,"column":1,"offset":59},"end":{"line":7,"column":33,"offset":91},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Words from the original author, Tim Griesser;","position":{"start":{"line":9,"column":1,"offset":93},"end":{"line":9,"column":46,"offset":138},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":93},"end":{"line":9,"column":46,"offset":138},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Nexus Schema was born out of my experience building several production GraphQL APIs, in different languages and frameworks. The first with vanilla ","position":{"start":{"line":11,"column":1,"offset":140},"end":{"line":11,"column":148,"offset":287},"indent":[]}},{"type":"link","title":null,"url":"https://github.com/graphql/graphql-js","children":[{"type":"text","value":"graphql-js","position":{"start":{"line":11,"column":149,"offset":288},"end":{"line":11,"column":159,"offset":298},"indent":[]}}],"position":{"start":{"line":11,"column":148,"offset":287},"end":{"line":11,"column":199,"offset":338},"indent":[]}},{"type":"text","value":", another schema-first with ","position":{"start":{"line":11,"column":199,"offset":338},"end":{"line":11,"column":227,"offset":366},"indent":[]}},{"type":"link","title":null,"url":"https://github.com/matthewmueller/graph.ql","children":[{"type":"text","value":"graph.ql","position":{"start":{"line":11,"column":228,"offset":367},"end":{"line":11,"column":236,"offset":375},"indent":[]}}],"position":{"start":{"line":11,"column":227,"offset":366},"end":{"line":11,"column":281,"offset":420},"indent":[]}},{"type":"text","value":" and later ","position":{"start":{"line":11,"column":281,"offset":420},"end":{"line":11,"column":292,"offset":431},"indent":[]}},{"type":"link","title":null,"url":"https://github.com/apollographql/graphql-tools","children":[{"type":"text","value":"graphql-tools","position":{"start":{"line":11,"column":293,"offset":432},"end":{"line":11,"column":306,"offset":445},"indent":[]}}],"position":{"start":{"line":11,"column":292,"offset":431},"end":{"line":11,"column":355,"offset":494},"indent":[]}},{"type":"text","value":". Following that with ","position":{"start":{"line":11,"column":355,"offset":494},"end":{"line":11,"column":377,"offset":516},"indent":[]}},{"type":"link","title":null,"url":"https://docs.graphene-python.org/en/latest/","children":[{"type":"text","value":"graphene-python","position":{"start":{"line":11,"column":378,"offset":517},"end":{"line":11,"column":393,"offset":532},"indent":[]}}],"position":{"start":{"line":11,"column":377,"offset":516},"end":{"line":11,"column":439,"offset":578},"indent":[]}},{"type":"text","value":" and most recently with a bit of ","position":{"start":{"line":11,"column":439,"offset":578},"end":{"line":11,"column":472,"offset":611},"indent":[]}},{"type":"link","title":null,"url":"http://graphql-ruby.org/","children":[{"type":"text","value":"graphql-ruby","position":{"start":{"line":11,"column":473,"offset":612},"end":{"line":11,"column":485,"offset":624},"indent":[]}}],"position":{"start":{"line":11,"column":472,"offset":611},"end":{"line":11,"column":512,"offset":651},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":11,"column":512,"offset":651},"end":{"line":11,"column":513,"offset":652},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":140},"end":{"line":11,"column":513,"offset":652},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"After working with the toolkits in other scripting languages, it felt like there was a gap in the JavaScript approaches. Schema-first development starts out great, by simply expressing your schema in the GraphQL Schema Definition Language (SDL) and providing resolvers matching to the types as needed you are up and running fast! No need for tons of requires or \"overhead\" to get a GraphQL server running.","position":{"start":{"line":13,"column":1,"offset":654},"end":{"line":13,"column":406,"offset":1059},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":654},"end":{"line":13,"column":406,"offset":1059},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"As your schema then grows to hundreds or thousands of types, manually curating these SDL fragments becomes tedious. Documentation changes can be tough. Modifying fields on interfaces can require manual changes to many implementing types, a process that can be quite error prone.","position":{"start":{"line":15,"column":1,"offset":1061},"end":{"line":15,"column":279,"offset":1339},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":1061},"end":{"line":15,"column":279,"offset":1339},"indent":[]}},{"type":"paragraph","children":[{"type":"emphasis","children":[{"type":"text","value":"If only there were a way to combine the simplicity of schema-first development, with the long-term maintainability of a definition-first approach.","position":{"start":{"line":17,"column":2,"offset":1342},"end":{"line":17,"column":148,"offset":1488},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":1341},"end":{"line":17,"column":149,"offset":1489},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":1341},"end":{"line":17,"column":149,"offset":1489},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"GraphQL Nexus aims to fill that void, making the process as simple as possible while also making good use of the runtime to introduce powerful ways of composing types, introducing type or schema wide changes, and much more.","position":{"start":{"line":19,"column":1,"offset":1491},"end":{"line":19,"column":224,"offset":1714},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":1491},"end":{"line":19,"column":224,"offset":1714},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The core idea of GraphQL Nexus draws from basing the schema off the SDL - keeping things declarative and simple to understand. It allows you to reference the type names as string literals rather than always need to import to reference types (you can do that too if you prefer).","position":{"start":{"line":21,"column":1,"offset":1716},"end":{"line":21,"column":278,"offset":1993},"indent":[]}}],"position":{"start":{"line":21,"column":1,"offset":1716},"end":{"line":21,"column":278,"offset":1993},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"By combining automatic type generation with some of the more powerful features of TypeScript - type merging, conditional types, and type inference, we can know exactly which type names we are referring to and able to use throughout our code. We can know both the parameters and the return type of resolvers without providing any type annotation. It takes a little getting used to, but it ends up leading to a great feedback loop of the types annotating themselves.","position":{"start":{"line":23,"column":1,"offset":1995},"end":{"line":23,"column":465,"offset":2459},"indent":[]}}],"position":{"start":{"line":23,"column":1,"offset":1995},"end":{"line":23,"column":465,"offset":2459},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Type Generation Details {docsify-ignore}","position":{"start":{"line":25,"column":4,"offset":2464},"end":{"line":25,"column":44,"offset":2504},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":2461},"end":{"line":25,"column":44,"offset":2504},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This is the most important piece to understand to get the most out of Nexus. It is relevant to JavaScript as well as TypeScript users, as tools like VSCode and ","position":{"start":{"line":27,"column":1,"offset":2506},"end":{"line":27,"column":161,"offset":2666},"indent":[]}},{"type":"inlineCode","value":"// @ts-check","position":{"start":{"line":27,"column":161,"offset":2666},"end":{"line":27,"column":175,"offset":2680},"indent":[]}},{"type":"text","value":" can utilize these types to aid in autocomplete or type-checking. A core goal of Nexus is to have the best possible type coverage with the least possible manual type annotation.","position":{"start":{"line":27,"column":175,"offset":2680},"end":{"line":27,"column":352,"offset":2857},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":2506},"end":{"line":27,"column":352,"offset":2857},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Overview {docsify-ignore}","position":{"start":{"line":29,"column":5,"offset":2863},"end":{"line":29,"column":30,"offset":2888},"indent":[]}}],"position":{"start":{"line":29,"column":1,"offset":2859},"end":{"line":29,"column":30,"offset":2888},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Nexus was designed with TypeScript in mind. In order to fully typecheck our GraphQL objects, we need to generate a number of types that combine the schema, any type or field configuration provided, and the GraphQL resolution algorithm to create as much type-safety as possible without any additional work importing and assigning types throughout the codebase.","position":{"start":{"line":31,"column":1,"offset":2890},"end":{"line":31,"column":360,"offset":3249},"indent":[]}}],"position":{"start":{"line":31,"column":1,"offset":2890},"end":{"line":31,"column":360,"offset":3249},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Root Types {docsify-ignore}","position":{"start":{"line":33,"column":5,"offset":3255},"end":{"line":33,"column":32,"offset":3282},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":3251},"end":{"line":33,"column":32,"offset":3282},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A ","position":{"start":{"line":35,"column":1,"offset":3284},"end":{"line":35,"column":3,"offset":3286},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"root type","position":{"start":{"line":35,"column":5,"offset":3288},"end":{"line":35,"column":14,"offset":3297},"indent":[]}}],"position":{"start":{"line":35,"column":3,"offset":3286},"end":{"line":35,"column":16,"offset":3299},"indent":[]}},{"type":"text","value":" is a type representation of the value used to resolve the fields of an object type. It is the object that will be passed as the first argument of ","position":{"start":{"line":35,"column":16,"offset":3299},"end":{"line":35,"column":163,"offset":3446},"indent":[]}},{"type":"inlineCode","value":"resolve","position":{"start":{"line":35,"column":163,"offset":3446},"end":{"line":35,"column":172,"offset":3455},"indent":[]}},{"type":"text","value":". It can be a plain JS object, a database model, a mongoose document, a JS class, anything that fulfills the contract defined by the GraphQL object type, based on the field definitions.","position":{"start":{"line":35,"column":172,"offset":3455},"end":{"line":35,"column":357,"offset":3640},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":3284},"end":{"line":35,"column":357,"offset":3640},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Scalars can also have backing types, representing the value they are parsed into.","position":{"start":{"line":37,"column":1,"offset":3642},"end":{"line":37,"column":82,"offset":3723},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":3642},"end":{"line":37,"column":82,"offset":3723},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Sometimes GraphQL types are passthrough, and don't have a dedicated type backing them. One such case would be in the ","position":{"start":{"line":39,"column":1,"offset":3725},"end":{"line":39,"column":118,"offset":3842},"indent":[]}},{"type":"inlineCode","value":"Edge","position":{"start":{"line":39,"column":118,"offset":3842},"end":{"line":39,"column":124,"offset":3848},"indent":[]}},{"type":"text","value":" of a Relay style pagination. In this case, Nexus will generate a type-definition which makes assumptions of the necessary value to fulfill the contract. If this is incorrect, you can always provide a concrete type for the object.","position":{"start":{"line":39,"column":124,"offset":3848},"end":{"line":39,"column":354,"offset":4078},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":3725},"end":{"line":39,"column":354,"offset":4078},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Field Type {docsify-ignore}","position":{"start":{"line":41,"column":5,"offset":4084},"end":{"line":41,"column":32,"offset":4111},"indent":[]}}],"position":{"start":{"line":41,"column":1,"offset":4080},"end":{"line":41,"column":32,"offset":4111},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A ","position":{"start":{"line":43,"column":1,"offset":4113},"end":{"line":43,"column":3,"offset":4115},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"field type","position":{"start":{"line":43,"column":5,"offset":4117},"end":{"line":43,"column":15,"offset":4127},"indent":[]}}],"position":{"start":{"line":43,"column":3,"offset":4115},"end":{"line":43,"column":17,"offset":4129},"indent":[]}},{"type":"text","value":" is the valid return value used to a field on an object type. In GraphQL, promises can be returned at every level of the type resolution, so we wrap the types in a ","position":{"start":{"line":43,"column":17,"offset":4129},"end":{"line":43,"column":181,"offset":4293},"indent":[]}},{"type":"inlineCode","value":"MaybePromiseDeep<T>","position":{"start":{"line":43,"column":181,"offset":4293},"end":{"line":43,"column":202,"offset":4314},"indent":[]}},{"type":"text","value":" type to express this.","position":{"start":{"line":43,"column":202,"offset":4314},"end":{"line":43,"column":224,"offset":4336},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":4113},"end":{"line":43,"column":224,"offset":4336},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Configuring our types {docsify-ignore}","position":{"start":{"line":45,"column":5,"offset":4342},"end":{"line":45,"column":43,"offset":4380},"indent":[]}}],"position":{"start":{"line":45,"column":1,"offset":4338},"end":{"line":45,"column":43,"offset":4380},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":47,"column":1,"offset":4382},"end":{"line":47,"column":5,"offset":4386},"indent":[]}},{"type":"link","title":null,"url":"https://github.com/prisma-labs/nexus/blob/develop/examples/ghost/src/ghost-schema.ts","children":[{"type":"text","value":"Ghost Example","position":{"start":{"line":47,"column":6,"offset":4387},"end":{"line":47,"column":19,"offset":4400},"indent":[]}}],"position":{"start":{"line":47,"column":5,"offset":4386},"end":{"line":47,"column":106,"offset":4487},"indent":[]}},{"type":"text","value":" is the best to look at for an example of how we're able to capture the types from existing runtime objects or definitions and merge them with our schema.","position":{"start":{"line":47,"column":106,"offset":4487},"end":{"line":47,"column":260,"offset":4641},"indent":[]}}],"position":{"start":{"line":47,"column":1,"offset":4382},"end":{"line":47,"column":260,"offset":4641},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":49,"column":1,"offset":4643},"end":{"line":49,"column":5,"offset":4647},"indent":[]}},{"type":"inlineCode","value":"makeSchema","position":{"start":{"line":49,"column":5,"offset":4647},"end":{"line":49,"column":17,"offset":4659},"indent":[]}},{"type":"text","value":" takes several options which helps us find the types we need to import into our generated schema, and customize where these generated types are output.","position":{"start":{"line":49,"column":17,"offset":4659},"end":{"line":49,"column":168,"offset":4810},"indent":[]}}],"position":{"start":{"line":49,"column":1,"offset":4643},"end":{"line":49,"column":168,"offset":4810},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"`@nexus/schema`\",\"metaTitle\":\"@nexus/schema\"}","position":{"start":{"line":52,"column":1,"offset":4813},"end":{"line":52,"column":84,"offset":4896},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":52,"column":84,"offset":4896}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"`@nexus/schema`\",\n  \"metaTitle\": \"@nexus/schema\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"\\\\n# \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@nexus/schema\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cli\"\n  }), \"npm install @nexus/schema\\n\")), mdx(\"section\", null, mdx(\"h4\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"why-nexus-docsify-ignore\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h4\"\n  }, {\n    \"href\": \"#why-nexus-docsify-ignore\",\n    \"aria-label\": \"why nexus docsify ignore permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Why Nexus? {docsify-ignore}\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Words from the original author, Tim Griesser;\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Nexus Schema was born out of my experience building several production GraphQL APIs, in different languages and frameworks. The first with vanilla \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/graphql/graphql-js\"\n  }), \"graphql-js\"), \", another schema-first with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/matthewmueller/graph.ql\"\n  }), \"graph.ql\"), \" and later \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/apollographql/graphql-tools\"\n  }), \"graphql-tools\"), \". Following that with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.graphene-python.org/en/latest/\"\n  }), \"graphene-python\"), \" and most recently with a bit of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://graphql-ruby.org/\"\n  }), \"graphql-ruby\"), \".\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"After working with the toolkits in other scripting languages, it felt like there was a gap in the JavaScript approaches. Schema-first development starts out great, by simply expressing your schema in the GraphQL Schema Definition Language (SDL) and providing resolvers matching to the types as needed you are up and running fast! No need for tons of requires or \\\"overhead\\\" to get a GraphQL server running.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"As your schema then grows to hundreds or thousands of types, manually curating these SDL fragments becomes tedious. Documentation changes can be tough. Modifying fields on interfaces can require manual changes to many implementing types, a process that can be quite error prone.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"If only there were a way to combine the simplicity of schema-first development, with the long-term maintainability of a definition-first approach.\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"GraphQL Nexus aims to fill that void, making the process as simple as possible while also making good use of the runtime to introduce powerful ways of composing types, introducing type or schema wide changes, and much more.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The core idea of GraphQL Nexus draws from basing the schema off the SDL - keeping things declarative and simple to understand. It allows you to reference the type names as string literals rather than always need to import to reference types (you can do that too if you prefer).\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"By combining automatic type generation with some of the more powerful features of TypeScript - type merging, conditional types, and type inference, we can know exactly which type names we are referring to and able to use throughout our code. We can know both the parameters and the return type of resolvers without providing any type annotation. It takes a little getting used to, but it ends up leading to a great feedback loop of the types annotating themselves.\")), mdx(\"section\", null, mdx(\"h2\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"type-generation-details-docsify-ignore\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#type-generation-details-docsify-ignore\",\n    \"aria-label\": \"type generation details docsify ignore permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Type Generation Details {docsify-ignore}\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This is the most important piece to understand to get the most out of Nexus. It is relevant to JavaScript as well as TypeScript users, as tools like VSCode and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"// @ts-check\"), \" can utilize these types to aid in autocomplete or type-checking. A core goal of Nexus is to have the best possible type coverage with the least possible manual type annotation.\"), mdx(\"section\", {\n    parentName: \"section\"\n  }, mdx(\"h3\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"overview-docsify-ignore\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#overview-docsify-ignore\",\n    \"aria-label\": \"overview docsify ignore permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Overview {docsify-ignore}\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Nexus was designed with TypeScript in mind. In order to fully typecheck our GraphQL objects, we need to generate a number of types that combine the schema, any type or field configuration provided, and the GraphQL resolution algorithm to create as much type-safety as possible without any additional work importing and assigning types throughout the codebase.\")), mdx(\"section\", {\n    parentName: \"section\"\n  }, mdx(\"h3\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"root-types-docsify-ignore\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#root-types-docsify-ignore\",\n    \"aria-label\": \"root types docsify ignore permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Root Types {docsify-ignore}\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"root type\"), \" is a type representation of the value used to resolve the fields of an object type. It is the object that will be passed as the first argument of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve\"), \". It can be a plain JS object, a database model, a mongoose document, a JS class, anything that fulfills the contract defined by the GraphQL object type, based on the field definitions.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Scalars can also have backing types, representing the value they are parsed into.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Sometimes GraphQL types are passthrough, and don't have a dedicated type backing them. One such case would be in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Edge\"), \" of a Relay style pagination. In this case, Nexus will generate a type-definition which makes assumptions of the necessary value to fulfill the contract. If this is incorrect, you can always provide a concrete type for the object.\")), mdx(\"section\", {\n    parentName: \"section\"\n  }, mdx(\"h3\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"field-type-docsify-ignore\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#field-type-docsify-ignore\",\n    \"aria-label\": \"field type docsify ignore permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Field Type {docsify-ignore}\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"field type\"), \" is the valid return value used to a field on an object type. In GraphQL, promises can be returned at every level of the type resolution, so we wrap the types in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MaybePromiseDeep<T>\"), \" type to express this.\")), mdx(\"section\", {\n    parentName: \"section\"\n  }, mdx(\"h3\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"configuring-our-types-docsify-ignore\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#configuring-our-types-docsify-ignore\",\n    \"aria-label\": \"configuring our types docsify ignore permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Configuring our types {docsify-ignore}\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/prisma-labs/nexus/blob/develop/examples/ghost/src/ghost-schema.ts\"\n  }), \"Ghost Example\"), \" is the best to look at for an example of how we're able to capture the types from existing runtime objects or definitions and merge them with our schema.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"makeSchema\"), \" takes several options which helps us find the types we need to import into our generated schema, and customize where these generated types are output.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"`@nexus/schema`\",\n  \"metaTitle\": \"@nexus/schema\"\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`\\\\n# `}<inlineCode parentName=\"p\">{`@nexus/schema`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cli\"\n      }}>{`npm install @nexus/schema\n`}</code></pre>\n    <section><h4 parentName=\"section\" {...{\n        \"id\": \"why-nexus-docsify-ignore\",\n        \"style\": {\n          \"position\": \"relative\"\n        }\n      }}><a parentName=\"h4\" {...{\n          \"href\": \"#why-nexus-docsify-ignore\",\n          \"aria-label\": \"why nexus docsify ignore permalink\",\n          \"className\": \"title-link before\"\n        }}><svg parentName=\"a\" {...{\n            \"width\": \"17\",\n            \"height\": \"18\",\n            \"viewBox\": \"0 0 17 18\",\n            \"fill\": \"none\",\n            \"xmlns\": \"http://www.w3.org/2000/svg\"\n          }}>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 6.33337H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 11.6666H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M6.75 1L5 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M12 1L10.25 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}</svg></a>{`Why Nexus? {docsify-ignore}`}</h4><p parentName=\"section\">{`Words from the original author, Tim Griesser;`}</p><p parentName=\"section\">{`Nexus Schema was born out of my experience building several production GraphQL APIs, in different languages and frameworks. The first with vanilla `}<a parentName=\"p\" {...{\n          \"href\": \"https://github.com/graphql/graphql-js\"\n        }}>{`graphql-js`}</a>{`, another schema-first with `}<a parentName=\"p\" {...{\n          \"href\": \"https://github.com/matthewmueller/graph.ql\"\n        }}>{`graph.ql`}</a>{` and later `}<a parentName=\"p\" {...{\n          \"href\": \"https://github.com/apollographql/graphql-tools\"\n        }}>{`graphql-tools`}</a>{`. Following that with `}<a parentName=\"p\" {...{\n          \"href\": \"https://docs.graphene-python.org/en/latest/\"\n        }}>{`graphene-python`}</a>{` and most recently with a bit of `}<a parentName=\"p\" {...{\n          \"href\": \"http://graphql-ruby.org/\"\n        }}>{`graphql-ruby`}</a>{`.`}</p><p parentName=\"section\">{`After working with the toolkits in other scripting languages, it felt like there was a gap in the JavaScript approaches. Schema-first development starts out great, by simply expressing your schema in the GraphQL Schema Definition Language (SDL) and providing resolvers matching to the types as needed you are up and running fast! No need for tons of requires or \"overhead\" to get a GraphQL server running.`}</p><p parentName=\"section\">{`As your schema then grows to hundreds or thousands of types, manually curating these SDL fragments becomes tedious. Documentation changes can be tough. Modifying fields on interfaces can require manual changes to many implementing types, a process that can be quite error prone.`}</p><p parentName=\"section\"><em parentName=\"p\">{`If only there were a way to combine the simplicity of schema-first development, with the long-term maintainability of a definition-first approach.`}</em></p><p parentName=\"section\">{`GraphQL Nexus aims to fill that void, making the process as simple as possible while also making good use of the runtime to introduce powerful ways of composing types, introducing type or schema wide changes, and much more.`}</p><p parentName=\"section\">{`The core idea of GraphQL Nexus draws from basing the schema off the SDL - keeping things declarative and simple to understand. It allows you to reference the type names as string literals rather than always need to import to reference types (you can do that too if you prefer).`}</p><p parentName=\"section\">{`By combining automatic type generation with some of the more powerful features of TypeScript - type merging, conditional types, and type inference, we can know exactly which type names we are referring to and able to use throughout our code. We can know both the parameters and the return type of resolvers without providing any type annotation. It takes a little getting used to, but it ends up leading to a great feedback loop of the types annotating themselves.`}</p></section>\n    <section><h2 parentName=\"section\" {...{\n        \"id\": \"type-generation-details-docsify-ignore\",\n        \"style\": {\n          \"position\": \"relative\"\n        }\n      }}><a parentName=\"h2\" {...{\n          \"href\": \"#type-generation-details-docsify-ignore\",\n          \"aria-label\": \"type generation details docsify ignore permalink\",\n          \"className\": \"title-link before\"\n        }}><svg parentName=\"a\" {...{\n            \"width\": \"17\",\n            \"height\": \"18\",\n            \"viewBox\": \"0 0 17 18\",\n            \"fill\": \"none\",\n            \"xmlns\": \"http://www.w3.org/2000/svg\"\n          }}>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 6.33337H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 11.6666H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M6.75 1L5 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M12 1L10.25 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}</svg></a>{`Type Generation Details {docsify-ignore}`}</h2><p parentName=\"section\">{`This is the most important piece to understand to get the most out of Nexus. It is relevant to JavaScript as well as TypeScript users, as tools like VSCode and `}<inlineCode parentName=\"p\">{`// @ts-check`}</inlineCode>{` can utilize these types to aid in autocomplete or type-checking. A core goal of Nexus is to have the best possible type coverage with the least possible manual type annotation.`}</p><section parentName=\"section\"><h3 parentName=\"section\" {...{\n          \"id\": \"overview-docsify-ignore\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }}><a parentName=\"h3\" {...{\n            \"href\": \"#overview-docsify-ignore\",\n            \"aria-label\": \"overview docsify ignore permalink\",\n            \"className\": \"title-link before\"\n          }}><svg parentName=\"a\" {...{\n              \"width\": \"17\",\n              \"height\": \"18\",\n              \"viewBox\": \"0 0 17 18\",\n              \"fill\": \"none\",\n              \"xmlns\": \"http://www.w3.org/2000/svg\"\n            }}>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M1.5 6.33337H15.5\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M1.5 11.6666H15.5\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M6.75 1L5 17\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M12 1L10.25 17\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}</svg></a>{`Overview {docsify-ignore}`}</h3><p parentName=\"section\">{`Nexus was designed with TypeScript in mind. In order to fully typecheck our GraphQL objects, we need to generate a number of types that combine the schema, any type or field configuration provided, and the GraphQL resolution algorithm to create as much type-safety as possible without any additional work importing and assigning types throughout the codebase.`}</p></section><section parentName=\"section\"><h3 parentName=\"section\" {...{\n          \"id\": \"root-types-docsify-ignore\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }}><a parentName=\"h3\" {...{\n            \"href\": \"#root-types-docsify-ignore\",\n            \"aria-label\": \"root types docsify ignore permalink\",\n            \"className\": \"title-link before\"\n          }}><svg parentName=\"a\" {...{\n              \"width\": \"17\",\n              \"height\": \"18\",\n              \"viewBox\": \"0 0 17 18\",\n              \"fill\": \"none\",\n              \"xmlns\": \"http://www.w3.org/2000/svg\"\n            }}>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M1.5 6.33337H15.5\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M1.5 11.6666H15.5\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M6.75 1L5 17\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M12 1L10.25 17\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}</svg></a>{`Root Types {docsify-ignore}`}</h3><p parentName=\"section\">{`A `}<strong parentName=\"p\">{`root type`}</strong>{` is a type representation of the value used to resolve the fields of an object type. It is the object that will be passed as the first argument of `}<inlineCode parentName=\"p\">{`resolve`}</inlineCode>{`. It can be a plain JS object, a database model, a mongoose document, a JS class, anything that fulfills the contract defined by the GraphQL object type, based on the field definitions.`}</p><p parentName=\"section\">{`Scalars can also have backing types, representing the value they are parsed into.`}</p><p parentName=\"section\">{`Sometimes GraphQL types are passthrough, and don't have a dedicated type backing them. One such case would be in the `}<inlineCode parentName=\"p\">{`Edge`}</inlineCode>{` of a Relay style pagination. In this case, Nexus will generate a type-definition which makes assumptions of the necessary value to fulfill the contract. If this is incorrect, you can always provide a concrete type for the object.`}</p></section><section parentName=\"section\"><h3 parentName=\"section\" {...{\n          \"id\": \"field-type-docsify-ignore\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }}><a parentName=\"h3\" {...{\n            \"href\": \"#field-type-docsify-ignore\",\n            \"aria-label\": \"field type docsify ignore permalink\",\n            \"className\": \"title-link before\"\n          }}><svg parentName=\"a\" {...{\n              \"width\": \"17\",\n              \"height\": \"18\",\n              \"viewBox\": \"0 0 17 18\",\n              \"fill\": \"none\",\n              \"xmlns\": \"http://www.w3.org/2000/svg\"\n            }}>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M1.5 6.33337H15.5\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M1.5 11.6666H15.5\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M6.75 1L5 17\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M12 1L10.25 17\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}</svg></a>{`Field Type {docsify-ignore}`}</h3><p parentName=\"section\">{`A `}<strong parentName=\"p\">{`field type`}</strong>{` is the valid return value used to a field on an object type. In GraphQL, promises can be returned at every level of the type resolution, so we wrap the types in a `}<inlineCode parentName=\"p\">{`MaybePromiseDeep<T>`}</inlineCode>{` type to express this.`}</p></section><section parentName=\"section\"><h3 parentName=\"section\" {...{\n          \"id\": \"configuring-our-types-docsify-ignore\",\n          \"style\": {\n            \"position\": \"relative\"\n          }\n        }}><a parentName=\"h3\" {...{\n            \"href\": \"#configuring-our-types-docsify-ignore\",\n            \"aria-label\": \"configuring our types docsify ignore permalink\",\n            \"className\": \"title-link before\"\n          }}><svg parentName=\"a\" {...{\n              \"width\": \"17\",\n              \"height\": \"18\",\n              \"viewBox\": \"0 0 17 18\",\n              \"fill\": \"none\",\n              \"xmlns\": \"http://www.w3.org/2000/svg\"\n            }}>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M1.5 6.33337H15.5\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M1.5 11.6666H15.5\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M6.75 1L5 17\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}<path parentName=\"svg\" {...{\n                \"d\": \"M12 1L10.25 17\",\n                \"stroke\": \"#CBD5E0\",\n                \"strokeWidth\": \"2\",\n                \"strokeLineCap\": \"round\",\n                \"strokeLineJoin\": \"round\"\n              }}></path>{`\n      `}</svg></a>{`Configuring our types {docsify-ignore}`}</h3><p parentName=\"section\">{`The `}<a parentName=\"p\" {...{\n            \"href\": \"https://github.com/prisma-labs/nexus/blob/develop/examples/ghost/src/ghost-schema.ts\"\n          }}>{`Ghost Example`}</a>{` is the best to look at for an example of how we're able to capture the types from existing runtime objects or definitions and merge them with our schema.`}</p><p parentName=\"section\">{`The `}<inlineCode parentName=\"p\">{`makeSchema`}</inlineCode>{` takes several options which helps us find the types we need to import into our generated schema, and customize where these generated types are output.`}</p></section></section>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}