{"expireTime":9007200846064525000,"key":"gatsby-plugin-mdx-entire-payload-c8ee6a90041cf8f9562a09b68ab4a36a-","val":{"mdast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"Chapter 6 ","position":{"start":{"line":1,"column":4,"offset":3},"end":{"line":1,"column":14,"offset":13},"indent":[]}},{"type":"jsx","value":"<br/>","position":{"start":{"line":1,"column":14,"offset":13},"end":{"line":1,"column":19,"offset":18},"indent":[]}},{"type":"text","value":" Testing With Prisma","position":{"start":{"line":1,"column":19,"offset":18},"end":{"line":1,"column":39,"offset":38},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":1,"column":39,"offset":38},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There's a couple of things you'll have to do in order to run integration tests against your API now that it's connected to a real development database. Please note that a lot of the following steps will most likely be simplified in the future. We're just not there yet. In this chapter, you'll learn about:","position":{"start":{"line":3,"column":1,"offset":40},"end":{"line":3,"column":307,"offset":346},"indent":[]}}],"position":{"start":{"line":3,"column":1,"offset":40},"end":{"line":3,"column":307,"offset":346},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Custom Jest environment","position":{"start":{"line":5,"column":3,"offset":350},"end":{"line":5,"column":26,"offset":373},"indent":[]}}],"position":{"start":{"line":5,"column":3,"offset":350},"end":{"line":5,"column":26,"offset":373},"indent":[]}}],"position":{"start":{"line":5,"column":1,"offset":348},"end":{"line":5,"column":26,"offset":373},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Integration test with a real database","position":{"start":{"line":6,"column":3,"offset":376},"end":{"line":6,"column":40,"offset":413},"indent":[]}}],"position":{"start":{"line":6,"column":3,"offset":376},"end":{"line":6,"column":40,"offset":413},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":374},"end":{"line":6,"column":40,"offset":413},"indent":[]}}],"position":{"start":{"line":5,"column":1,"offset":348},"end":{"line":6,"column":40,"offset":413},"indent":[1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"How does it work?","position":{"start":{"line":8,"column":4,"offset":418},"end":{"line":8,"column":21,"offset":435},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":415},"end":{"line":8,"column":21,"offset":435},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"To perform integration testing against a real database, here are the high level steps we will follow ","position":{"start":{"line":10,"column":1,"offset":437},"end":{"line":10,"column":102,"offset":538},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"for every tests","position":{"start":{"line":10,"column":103,"offset":539},"end":{"line":10,"column":118,"offset":554},"indent":[]}}],"position":{"start":{"line":10,"column":102,"offset":538},"end":{"line":10,"column":119,"offset":555},"indent":[]}},{"type":"text","value":":","position":{"start":{"line":10,"column":119,"offset":555},"end":{"line":10,"column":120,"offset":556},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":437},"end":{"line":10,"column":120,"offset":556},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Connect to a Postgres database. Most likely your dev database.","position":{"start":{"line":12,"column":3,"offset":560},"end":{"line":12,"column":65,"offset":622},"indent":[]}}],"position":{"start":{"line":12,"column":3,"offset":560},"end":{"line":12,"column":65,"offset":622},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":558},"end":{"line":12,"column":65,"offset":622},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Migrate our database schema to a randomly generated schema of that database. This ensures that every tests runs from a clean un-seeded database","position":{"start":{"line":13,"column":3,"offset":625},"end":{"line":13,"column":146,"offset":768},"indent":[]}}],"position":{"start":{"line":13,"column":3,"offset":625},"end":{"line":13,"column":146,"offset":768},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":623},"end":{"line":13,"column":146,"offset":768},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Make the Prisma Client connect to that Postgres schema","position":{"start":{"line":14,"column":3,"offset":771},"end":{"line":14,"column":57,"offset":825},"indent":[]}}],"position":{"start":{"line":14,"column":3,"offset":771},"end":{"line":14,"column":57,"offset":825},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":769},"end":{"line":14,"column":57,"offset":825},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Run your test","position":{"start":{"line":15,"column":3,"offset":828},"end":{"line":15,"column":16,"offset":841},"indent":[]}}],"position":{"start":{"line":15,"column":3,"offset":828},"end":{"line":15,"column":16,"offset":841},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":826},"end":{"line":15,"column":16,"offset":841},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Teardown the schema entirely","position":{"start":{"line":16,"column":3,"offset":844},"end":{"line":16,"column":31,"offset":872},"indent":[]}}],"position":{"start":{"line":16,"column":3,"offset":844},"end":{"line":16,"column":31,"offset":872},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":842},"end":{"line":16,"column":31,"offset":872},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":558},"end":{"line":16,"column":31,"offset":872},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Setting up the environment","position":{"start":{"line":18,"column":4,"offset":877},"end":{"line":18,"column":30,"offset":903},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":874},"end":{"line":18,"column":30,"offset":903},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"To achieve some of the steps described above, we'll use a custom Jest environment.","position":{"start":{"line":20,"column":1,"offset":905},"end":{"line":20,"column":83,"offset":987},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":905},"end":{"line":20,"column":83,"offset":987},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Create a ","position":{"start":{"line":22,"column":1,"offset":989},"end":{"line":22,"column":10,"offset":998},"indent":[]}},{"type":"inlineCode","value":"tests/nexus-test-environment.js","position":{"start":{"line":22,"column":10,"offset":998},"end":{"line":22,"column":43,"offset":1031},"indent":[]}},{"type":"text","value":" module and copy & paste the following to it","position":{"start":{"line":22,"column":43,"offset":1031},"end":{"line":22,"column":87,"offset":1075},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":989},"end":{"line":22,"column":87,"offset":1075},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// tests/nexus-test-environment.js\nconst { Client } = require('pg')\nconst NodeEnvironment = require('jest-environment-node')\nconst { nanoid } = require('nanoid')\nconst util = require('util')\nconst exec = util.promisify(require('child_process').exec)\n\nconst prismaBinary = './node_modules/.bin/prisma'\n\n/**\n * Custom test environment for Nexus, Prisma and Postgres\n */\nclass PrismaTestEnvironment extends NodeEnvironment {\n  constructor(config) {\n    super(config)\n\n    // Generate a unique schema identifier for this test context\n    this.schema = `test_${nanoid()}`\n\n    // Generate the pg connection string for the test schema\n    this.databaseUrl = `postgres://postgres:postgres@localhost:5432/testing?schema=${this.schema}`\n  }\n\n  async setup() {\n    // Set the required environment variable to contain the connection string\n    // to our database test schema\n    process.env.DATABASE_URL = this.databaseUrl\n    this.global.process.env.DATABASE_URL = this.databaseUrl\n\n    // Run the migrations to ensure our schema has the required structure\n    await exec(`${prismaBinary} migrate up --create-db --experimental`)\n\n    return super.setup()\n  }\n\n  async teardown() {\n    // Drop the schema after the tests have completed\n    const client = new Client({\n      connectionString: this.databaseUrl,\n    })\n    await client.connect()\n    await client.query(`DROP SCHEMA IF EXISTS \"${this.schema}\" CASCADE`)\n    await client.end()\n  }\n}\n\nmodule.exports = PrismaTestEnvironment","position":{"start":{"line":24,"column":1,"offset":1077},"end":{"line":72,"column":4,"offset":2561},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Make sure that the ","position":{"start":{"line":74,"column":1,"offset":2563},"end":{"line":74,"column":20,"offset":2582},"indent":[]}},{"type":"inlineCode","value":"databaseUrl","position":{"start":{"line":74,"column":20,"offset":2582},"end":{"line":74,"column":33,"offset":2595},"indent":[]}},{"type":"text","value":" property has the right credentials to connect to your own database.\nLeave the ","position":{"start":{"line":74,"column":33,"offset":2595},"end":{"line":75,"column":11,"offset":2674},"indent":[1]}},{"type":"inlineCode","value":"/testing?schema=...","position":{"start":{"line":75,"column":11,"offset":2674},"end":{"line":75,"column":32,"offset":2695},"indent":[]}},{"type":"text","value":" part though. This ensures that your tests will add data to your Postgres instance in a separate database called ","position":{"start":{"line":75,"column":32,"offset":2695},"end":{"line":75,"column":145,"offset":2808},"indent":[]}},{"type":"inlineCode","value":"testing","position":{"start":{"line":75,"column":145,"offset":2808},"end":{"line":75,"column":154,"offset":2817},"indent":[]}},{"type":"text","value":" in a schema that randomly generated.","position":{"start":{"line":75,"column":154,"offset":2817},"end":{"line":75,"column":191,"offset":2854},"indent":[]}}],"position":{"start":{"line":74,"column":1,"offset":2563},"end":{"line":75,"column":191,"offset":2854},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"Then, configure Jest to use that custom environment in your ","position":{"start":{"line":77,"column":1,"offset":2856},"end":{"line":77,"column":61,"offset":2916},"indent":[]}},{"type":"inlineCode","value":"package.json","position":{"start":{"line":77,"column":61,"offset":2916},"end":{"line":77,"column":75,"offset":2930},"indent":[]}}],"position":{"start":{"line":77,"column":1,"offset":2856},"end":{"line":77,"column":75,"offset":2930},"indent":[]}},{"type":"code","lang":"diff","meta":null,"value":"\"jest\": {\n  \"preset\": \"ts-jest\",\n- \"testEnvironment\": \"node\",\n+ \"testEnvironment\": \"./tests/nexus-test-environment.js\"\n}","position":{"start":{"line":79,"column":1,"offset":2932},"end":{"line":85,"column":4,"offset":3064},"indent":[1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Finally, thanks to the ","position":{"start":{"line":87,"column":1,"offset":3066},"end":{"line":87,"column":24,"offset":3089},"indent":[]}},{"type":"inlineCode","value":"nexus-plugin-prisma","position":{"start":{"line":87,"column":24,"offset":3089},"end":{"line":87,"column":45,"offset":3110},"indent":[]}},{"type":"text","value":", the test context that we previously used should now be augmented with a ","position":{"start":{"line":87,"column":45,"offset":3110},"end":{"line":87,"column":119,"offset":3184},"indent":[]}},{"type":"inlineCode","value":"ctx.app.db","position":{"start":{"line":87,"column":119,"offset":3184},"end":{"line":87,"column":131,"offset":3196},"indent":[]}},{"type":"text","value":" property. That db property holds an instance of the Prisma Client to give you access to the underlying testing database. This is useful, for instance, to seed your database or make sure that some data was properly inserted.","position":{"start":{"line":87,"column":131,"offset":3196},"end":{"line":87,"column":355,"offset":3420},"indent":[]}}],"position":{"start":{"line":87,"column":1,"offset":3066},"end":{"line":87,"column":355,"offset":3420},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The last thing we need to do to setup our environment is to make sure that we properly close the database connection after all tests. To do that, head to your ","position":{"start":{"line":89,"column":1,"offset":3422},"end":{"line":89,"column":160,"offset":3581},"indent":[]}},{"type":"inlineCode","value":"tests/__helpers.ts","position":{"start":{"line":89,"column":160,"offset":3581},"end":{"line":89,"column":180,"offset":3601},"indent":[]}},{"type":"text","value":" module and add the following","position":{"start":{"line":89,"column":180,"offset":3601},"end":{"line":89,"column":209,"offset":3630},"indent":[]}}],"position":{"start":{"line":89,"column":1,"offset":3422},"end":{"line":89,"column":209,"offset":3630},"indent":[]}},{"type":"code","lang":"diff","meta":null,"value":"import {\n  createTestContext as originalCreateTestContext,\n  TestContext,\n} from 'nexus/testing';\n\nexport function createTestContext(): TestContext {\n  let ctx = {} as TestContext;\n\n  beforeAll(async () => {\n    Object.assign(ctx, await originalCreateTestContext());\n\n    await ctx.app.start();\n  });\n\n  afterAll(async () => {\n+   await ctx.app.db.client.disconnect();\n    await ctx.app.stop();\n  });\n\n  return ctx;\n}","position":{"start":{"line":91,"column":1,"offset":3632},"end":{"line":113,"column":4,"offset":4061},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Updating our test","position":{"start":{"line":115,"column":4,"offset":4066},"end":{"line":115,"column":21,"offset":4083},"indent":[]}}],"position":{"start":{"line":115,"column":1,"offset":4063},"end":{"line":115,"column":21,"offset":4083},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We're ready to update our test so that it uses our database. Wait though. Is there even something to change?\nNo, absolutely nothing. In fact, you can already try running Jest again and your test should pass. That's precisely the point of integration tests.","position":{"start":{"line":117,"column":1,"offset":4085},"end":{"line":118,"column":148,"offset":4341},"indent":[1]}}],"position":{"start":{"line":117,"column":1,"offset":4085},"end":{"line":118,"column":148,"offset":4341},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"There's one thing we can do though. If you remember our previous test, the only part we couldn't test was whether or not the data had properly been persisted into the database.","position":{"start":{"line":120,"column":1,"offset":4343},"end":{"line":120,"column":177,"offset":4519},"indent":[]}}],"position":{"start":{"line":120,"column":1,"offset":4343},"end":{"line":120,"column":177,"offset":4519},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Let's use the ","position":{"start":{"line":122,"column":1,"offset":4521},"end":{"line":122,"column":15,"offset":4535},"indent":[]}},{"type":"inlineCode","value":"ctx.app.db","position":{"start":{"line":122,"column":15,"offset":4535},"end":{"line":122,"column":27,"offset":4547},"indent":[]}},{"type":"text","value":" property to fetch our database right after we've published the draft to ensure that it's been created by snapshotting the result.","position":{"start":{"line":122,"column":27,"offset":4547},"end":{"line":122,"column":157,"offset":4677},"indent":[]}}],"position":{"start":{"line":122,"column":1,"offset":4521},"end":{"line":122,"column":157,"offset":4677},"indent":[]}},{"type":"code","lang":"diff","meta":null,"value":"// tests/Post.test.ts\n\nit('ensures that a draft can be created and published', async () => {\n  // ...\n\n  // Publish the previously created draft\n  const publishResult = await ctx.app.query(\n    `\n    mutation publishDraft($draftId: Int!) {\n      publish(draftId: $draftId) {\n        id\n        title\n        body\n        published\n      }\n    }\n  `,\n    { draftId: draftResult.createDraft.id }\n  )\n\n  // Snapshot the published draft and expect `published` to be true\n  expect(publishResult).toMatchInlineSnapshot(`\n    Object {\n      \"publish\": Object {\n        \"body\": \"...\",\n        \"id\": 1,\n        \"published\": true,\n        \"title\": \"Nexus\",\n      },\n    }\n  `)\n\n+ const persistedData = await ctx.app.db.client.post.findMany()\n\n+ expect(persistedData).toMatchInlineSnapshot()\n})","position":{"start":{"line":124,"column":1,"offset":4679},"end":{"line":161,"column":4,"offset":5474},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The new snapshot should look like the following. It proves that our database did persist that data and that we have exactly one item in it.","position":{"start":{"line":163,"column":1,"offset":5476},"end":{"line":163,"column":140,"offset":5615},"indent":[]}}],"position":{"start":{"line":163,"column":1,"offset":5476},"end":{"line":163,"column":140,"offset":5615},"indent":[]}},{"type":"code","lang":"diff","meta":null,"value":"expect(persistedData).toMatchInlineSnapshot(`\n+   Array [\n+     Object {\n+       \"body\": \"...\",\n+       \"id\": 1,\n+       \"published\": true,\n+       \"title\": \"Nexus\",\n+     },\n+   ]\n  `)","position":{"start":{"line":165,"column":1,"offset":5617},"end":{"line":176,"column":4,"offset":5814},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Wrapping up","position":{"start":{"line":178,"column":4,"offset":5819},"end":{"line":178,"column":15,"offset":5830},"indent":[]}}],"position":{"start":{"line":178,"column":1,"offset":5816},"end":{"line":178,"column":15,"offset":5830},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Congrats, you've performed your first real-world integration test. The fact that integration tests are completely decoupled from the implementation of your GraphQL API makes it a lot easier to maintain your test suite as you evolve your API. What matters is only the data that it produces, which also helps you cover your app a lot more than a single unit test.","position":{"start":{"line":180,"column":1,"offset":5832},"end":{"line":180,"column":362,"offset":6193},"indent":[]}}],"position":{"start":{"line":180,"column":1,"offset":5832},"end":{"line":180,"column":362,"offset":6193},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"About our app, it's starting to take shape but it's still lacking something pretty important in any application: authentication.","position":{"start":{"line":182,"column":1,"offset":6195},"end":{"line":182,"column":129,"offset":6323},"indent":[]}}],"position":{"start":{"line":182,"column":1,"offset":6195},"end":{"line":182,"column":129,"offset":6323},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Come onto the next chapter to get that added to your app!","position":{"start":{"line":184,"column":1,"offset":6325},"end":{"line":184,"column":58,"offset":6382},"indent":[]}}],"position":{"start":{"line":184,"column":1,"offset":6325},"end":{"line":184,"column":58,"offset":6382},"indent":[]}},{"type":"jsx","value":"<div class=\"NextIs NextChapter\"></div>","position":{"start":{"line":186,"column":1,"offset":6384},"end":{"line":186,"column":39,"offset":6422},"indent":[]}},{"type":"paragraph","children":[{"type":"link","title":null,"url":"/tutorial/chapter-7-authentication","children":[{"type":"text","value":"➳","position":{"start":{"line":188,"column":2,"offset":6425},"end":{"line":188,"column":3,"offset":6426},"indent":[]}}],"position":{"start":{"line":188,"column":1,"offset":6424},"end":{"line":188,"column":40,"offset":6463},"indent":[]}}],"position":{"start":{"line":188,"column":1,"offset":6424},"end":{"line":188,"column":40,"offset":6463},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"6. Testing With Prisma\"}","position":{"start":{"line":191,"column":1,"offset":6466},"end":{"line":191,"column":63,"offset":6528},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":191,"column":63,"offset":6528}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"6. Testing With Prisma\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"section\", null, mdx(\"h2\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"chapter-6-br-testing-with-prisma\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#chapter-6-br-testing-with-prisma\",\n    \"aria-label\": \"chapter 6 br testing with prisma permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Chapter 6 \", mdx(\"br\", null), \" Testing With Prisma\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"There's a couple of things you'll have to do in order to run integration tests against your API now that it's connected to a real development database. Please note that a lot of the following steps will most likely be simplified in the future. We're just not there yet. In this chapter, you'll learn about:\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Custom Jest environment\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Integration test with a real database\"))), mdx(\"section\", null, mdx(\"h2\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"how-does-it-work\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#how-does-it-work\",\n    \"aria-label\": \"how does it work permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"How does it work?\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"To perform integration testing against a real database, here are the high level steps we will follow \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"for every tests\"), \":\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Connect to a Postgres database. Most likely your dev database.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Migrate our database schema to a randomly generated schema of that database. This ensures that every tests runs from a clean un-seeded database\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Make the Prisma Client connect to that Postgres schema\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Run your test\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Teardown the schema entirely\"))), mdx(\"section\", null, mdx(\"h2\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"setting-up-the-environment\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#setting-up-the-environment\",\n    \"aria-label\": \"setting up the environment permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Setting up the environment\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"To achieve some of the steps described above, we'll use a custom Jest environment.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tests/nexus-test-environment.js\"), \" module and copy & paste the following to it\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// tests/nexus-test-environment.js\\nconst { Client } = require('pg')\\nconst NodeEnvironment = require('jest-environment-node')\\nconst { nanoid } = require('nanoid')\\nconst util = require('util')\\nconst exec = util.promisify(require('child_process').exec)\\n\\nconst prismaBinary = './node_modules/.bin/prisma'\\n\\n/**\\n * Custom test environment for Nexus, Prisma and Postgres\\n */\\nclass PrismaTestEnvironment extends NodeEnvironment {\\n  constructor(config) {\\n    super(config)\\n\\n    // Generate a unique schema identifier for this test context\\n    this.schema = `test_${nanoid()}`\\n\\n    // Generate the pg connection string for the test schema\\n    this.databaseUrl = `postgres://postgres:postgres@localhost:5432/testing?schema=${this.schema}`\\n  }\\n\\n  async setup() {\\n    // Set the required environment variable to contain the connection string\\n    // to our database test schema\\n    process.env.DATABASE_URL = this.databaseUrl\\n    this.global.process.env.DATABASE_URL = this.databaseUrl\\n\\n    // Run the migrations to ensure our schema has the required structure\\n    await exec(`${prismaBinary} migrate up --create-db --experimental`)\\n\\n    return super.setup()\\n  }\\n\\n  async teardown() {\\n    // Drop the schema after the tests have completed\\n    const client = new Client({\\n      connectionString: this.databaseUrl,\\n    })\\n    await client.connect()\\n    await client.query(`DROP SCHEMA IF EXISTS \\\"${this.schema}\\\" CASCADE`)\\n    await client.end()\\n  }\\n}\\n\\nmodule.exports = PrismaTestEnvironment\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Make sure that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"databaseUrl\"), \" property has the right credentials to connect to your own database.\\nLeave the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/testing?schema=...\"), \" part though. This ensures that your tests will add data to your Postgres instance in a separate database called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"testing\"), \" in a schema that randomly generated.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Then, configure Jest to use that custom environment in your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package.json\")), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"\\\"jest\\\": {\\n  \\\"preset\\\": \\\"ts-jest\\\",\\n- \\\"testEnvironment\\\": \\\"node\\\",\\n+ \\\"testEnvironment\\\": \\\"./tests/nexus-test-environment.js\\\"\\n}\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Finally, thanks to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nexus-plugin-prisma\"), \", the test context that we previously used should now be augmented with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ctx.app.db\"), \" property. That db property holds an instance of the Prisma Client to give you access to the underlying testing database. This is useful, for instance, to seed your database or make sure that some data was properly inserted.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The last thing we need to do to setup our environment is to make sure that we properly close the database connection after all tests. To do that, head to your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tests/__helpers.ts\"), \" module and add the following\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"import {\\n  createTestContext as originalCreateTestContext,\\n  TestContext,\\n} from 'nexus/testing';\\n\\nexport function createTestContext(): TestContext {\\n  let ctx = {} as TestContext;\\n\\n  beforeAll(async () => {\\n    Object.assign(ctx, await originalCreateTestContext());\\n\\n    await ctx.app.start();\\n  });\\n\\n  afterAll(async () => {\\n+   await ctx.app.db.client.disconnect();\\n    await ctx.app.stop();\\n  });\\n\\n  return ctx;\\n}\\n\"))), mdx(\"section\", null, mdx(\"h2\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"updating-our-test\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#updating-our-test\",\n    \"aria-label\": \"updating our test permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Updating our test\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"We're ready to update our test so that it uses our database. Wait though. Is there even something to change?\\nNo, absolutely nothing. In fact, you can already try running Jest again and your test should pass. That's precisely the point of integration tests.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"There's one thing we can do though. If you remember our previous test, the only part we couldn't test was whether or not the data had properly been persisted into the database.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Let's use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ctx.app.db\"), \" property to fetch our database right after we've published the draft to ensure that it's been created by snapshotting the result.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"// tests/Post.test.ts\\n\\nit('ensures that a draft can be created and published', async () => {\\n  // ...\\n\\n  // Publish the previously created draft\\n  const publishResult = await ctx.app.query(\\n    `\\n    mutation publishDraft($draftId: Int!) {\\n      publish(draftId: $draftId) {\\n        id\\n        title\\n        body\\n        published\\n      }\\n    }\\n  `,\\n    { draftId: draftResult.createDraft.id }\\n  )\\n\\n  // Snapshot the published draft and expect `published` to be true\\n  expect(publishResult).toMatchInlineSnapshot(`\\n    Object {\\n      \\\"publish\\\": Object {\\n        \\\"body\\\": \\\"...\\\",\\n        \\\"id\\\": 1,\\n        \\\"published\\\": true,\\n        \\\"title\\\": \\\"Nexus\\\",\\n      },\\n    }\\n  `)\\n\\n+ const persistedData = await ctx.app.db.client.post.findMany()\\n\\n+ expect(persistedData).toMatchInlineSnapshot()\\n})\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The new snapshot should look like the following. It proves that our database did persist that data and that we have exactly one item in it.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"expect(persistedData).toMatchInlineSnapshot(`\\n+   Array [\\n+     Object {\\n+       \\\"body\\\": \\\"...\\\",\\n+       \\\"id\\\": 1,\\n+       \\\"published\\\": true,\\n+       \\\"title\\\": \\\"Nexus\\\",\\n+     },\\n+   ]\\n  `)\\n\"))), mdx(\"section\", null, mdx(\"h2\", _extends({\n    parentName: \"section\"\n  }, {\n    \"id\": \"wrapping-up\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }), mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#wrapping-up\",\n    \"aria-label\": \"wrapping up permalink\",\n    \"className\": \"title-link before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"width\": \"17\",\n    \"height\": \"18\",\n    \"viewBox\": \"0 0 17 18\",\n    \"fill\": \"none\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  }), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 6.33337H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M1.5 11.6666H15.5\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M6.75 1L5 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \", mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"d\": \"M12 1L10.25 17\",\n    \"stroke\": \"#CBD5E0\",\n    \"strokeWidth\": \"2\",\n    \"strokeLineCap\": \"round\",\n    \"strokeLineJoin\": \"round\"\n  })), \"\\n      \")), \"Wrapping up\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Congrats, you've performed your first real-world integration test. The fact that integration tests are completely decoupled from the implementation of your GraphQL API makes it a lot easier to maintain your test suite as you evolve your API. What matters is only the data that it produces, which also helps you cover your app a lot more than a single unit test.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"About our app, it's starting to take shape but it's still lacking something pretty important in any application: authentication.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Come onto the next chapter to get that added to your app!\"), mdx(\"div\", {\n    className: \"NextIs NextChapter\"\n  }), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/tutorial/chapter-7-authentication\"\n  }), \"\\u27B3\"))));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"6. Testing With Prisma\"\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <section><h2 parentName=\"section\" {...{\n        \"id\": \"chapter-6-br-testing-with-prisma\",\n        \"style\": {\n          \"position\": \"relative\"\n        }\n      }}><a parentName=\"h2\" {...{\n          \"href\": \"#chapter-6-br-testing-with-prisma\",\n          \"aria-label\": \"chapter 6 br testing with prisma permalink\",\n          \"className\": \"title-link before\"\n        }}><svg parentName=\"a\" {...{\n            \"width\": \"17\",\n            \"height\": \"18\",\n            \"viewBox\": \"0 0 17 18\",\n            \"fill\": \"none\",\n            \"xmlns\": \"http://www.w3.org/2000/svg\"\n          }}>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 6.33337H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 11.6666H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M6.75 1L5 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M12 1L10.25 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}</svg></a>{`Chapter 6 `}<br />{` Testing With Prisma`}</h2><p parentName=\"section\">{`There's a couple of things you'll have to do in order to run integration tests against your API now that it's connected to a real development database. Please note that a lot of the following steps will most likely be simplified in the future. We're just not there yet. In this chapter, you'll learn about:`}</p><ul parentName=\"section\">\n        <li parentName=\"ul\">{`Custom Jest environment`}</li>\n        <li parentName=\"ul\">{`Integration test with a real database`}</li>\n      </ul></section>\n    <section><h2 parentName=\"section\" {...{\n        \"id\": \"how-does-it-work\",\n        \"style\": {\n          \"position\": \"relative\"\n        }\n      }}><a parentName=\"h2\" {...{\n          \"href\": \"#how-does-it-work\",\n          \"aria-label\": \"how does it work permalink\",\n          \"className\": \"title-link before\"\n        }}><svg parentName=\"a\" {...{\n            \"width\": \"17\",\n            \"height\": \"18\",\n            \"viewBox\": \"0 0 17 18\",\n            \"fill\": \"none\",\n            \"xmlns\": \"http://www.w3.org/2000/svg\"\n          }}>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 6.33337H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 11.6666H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M6.75 1L5 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M12 1L10.25 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}</svg></a>{`How does it work?`}</h2><p parentName=\"section\">{`To perform integration testing against a real database, here are the high level steps we will follow `}<em parentName=\"p\">{`for every tests`}</em>{`:`}</p><ul parentName=\"section\">\n        <li parentName=\"ul\">{`Connect to a Postgres database. Most likely your dev database.`}</li>\n        <li parentName=\"ul\">{`Migrate our database schema to a randomly generated schema of that database. This ensures that every tests runs from a clean un-seeded database`}</li>\n        <li parentName=\"ul\">{`Make the Prisma Client connect to that Postgres schema`}</li>\n        <li parentName=\"ul\">{`Run your test`}</li>\n        <li parentName=\"ul\">{`Teardown the schema entirely`}</li>\n      </ul></section>\n    <section><h2 parentName=\"section\" {...{\n        \"id\": \"setting-up-the-environment\",\n        \"style\": {\n          \"position\": \"relative\"\n        }\n      }}><a parentName=\"h2\" {...{\n          \"href\": \"#setting-up-the-environment\",\n          \"aria-label\": \"setting up the environment permalink\",\n          \"className\": \"title-link before\"\n        }}><svg parentName=\"a\" {...{\n            \"width\": \"17\",\n            \"height\": \"18\",\n            \"viewBox\": \"0 0 17 18\",\n            \"fill\": \"none\",\n            \"xmlns\": \"http://www.w3.org/2000/svg\"\n          }}>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 6.33337H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 11.6666H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M6.75 1L5 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M12 1L10.25 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}</svg></a>{`Setting up the environment`}</h2><p parentName=\"section\">{`To achieve some of the steps described above, we'll use a custom Jest environment.`}</p><p parentName=\"section\">{`Create a `}<inlineCode parentName=\"p\">{`tests/nexus-test-environment.js`}</inlineCode>{` module and copy & paste the following to it`}</p><pre parentName=\"section\"><code parentName=\"pre\" {...{\n          \"className\": \"language-js\"\n        }}>{`// tests/nexus-test-environment.js\nconst { Client } = require('pg')\nconst NodeEnvironment = require('jest-environment-node')\nconst { nanoid } = require('nanoid')\nconst util = require('util')\nconst exec = util.promisify(require('child_process').exec)\n\nconst prismaBinary = './node_modules/.bin/prisma'\n\n/**\n * Custom test environment for Nexus, Prisma and Postgres\n */\nclass PrismaTestEnvironment extends NodeEnvironment {\n  constructor(config) {\n    super(config)\n\n    // Generate a unique schema identifier for this test context\n    this.schema = \\`test_\\${nanoid()}\\`\n\n    // Generate the pg connection string for the test schema\n    this.databaseUrl = \\`postgres://postgres:postgres@localhost:5432/testing?schema=\\${this.schema}\\`\n  }\n\n  async setup() {\n    // Set the required environment variable to contain the connection string\n    // to our database test schema\n    process.env.DATABASE_URL = this.databaseUrl\n    this.global.process.env.DATABASE_URL = this.databaseUrl\n\n    // Run the migrations to ensure our schema has the required structure\n    await exec(\\`\\${prismaBinary} migrate up --create-db --experimental\\`)\n\n    return super.setup()\n  }\n\n  async teardown() {\n    // Drop the schema after the tests have completed\n    const client = new Client({\n      connectionString: this.databaseUrl,\n    })\n    await client.connect()\n    await client.query(\\`DROP SCHEMA IF EXISTS \"\\${this.schema}\" CASCADE\\`)\n    await client.end()\n  }\n}\n\nmodule.exports = PrismaTestEnvironment\n`}</code></pre><p parentName=\"section\">{`Make sure that the `}<inlineCode parentName=\"p\">{`databaseUrl`}</inlineCode>{` property has the right credentials to connect to your own database.\nLeave the `}<inlineCode parentName=\"p\">{`/testing?schema=...`}</inlineCode>{` part though. This ensures that your tests will add data to your Postgres instance in a separate database called `}<inlineCode parentName=\"p\">{`testing`}</inlineCode>{` in a schema that randomly generated.`}</p><p parentName=\"section\">{`Then, configure Jest to use that custom environment in your `}<inlineCode parentName=\"p\">{`package.json`}</inlineCode></p><pre parentName=\"section\"><code parentName=\"pre\" {...{\n          \"className\": \"language-diff\"\n        }}>{`\"jest\": {\n  \"preset\": \"ts-jest\",\n- \"testEnvironment\": \"node\",\n+ \"testEnvironment\": \"./tests/nexus-test-environment.js\"\n}\n`}</code></pre><p parentName=\"section\">{`Finally, thanks to the `}<inlineCode parentName=\"p\">{`nexus-plugin-prisma`}</inlineCode>{`, the test context that we previously used should now be augmented with a `}<inlineCode parentName=\"p\">{`ctx.app.db`}</inlineCode>{` property. That db property holds an instance of the Prisma Client to give you access to the underlying testing database. This is useful, for instance, to seed your database or make sure that some data was properly inserted.`}</p><p parentName=\"section\">{`The last thing we need to do to setup our environment is to make sure that we properly close the database connection after all tests. To do that, head to your `}<inlineCode parentName=\"p\">{`tests/__helpers.ts`}</inlineCode>{` module and add the following`}</p><pre parentName=\"section\"><code parentName=\"pre\" {...{\n          \"className\": \"language-diff\"\n        }}>{`import {\n  createTestContext as originalCreateTestContext,\n  TestContext,\n} from 'nexus/testing';\n\nexport function createTestContext(): TestContext {\n  let ctx = {} as TestContext;\n\n  beforeAll(async () => {\n    Object.assign(ctx, await originalCreateTestContext());\n\n    await ctx.app.start();\n  });\n\n  afterAll(async () => {\n+   await ctx.app.db.client.disconnect();\n    await ctx.app.stop();\n  });\n\n  return ctx;\n}\n`}</code></pre></section>\n    <section><h2 parentName=\"section\" {...{\n        \"id\": \"updating-our-test\",\n        \"style\": {\n          \"position\": \"relative\"\n        }\n      }}><a parentName=\"h2\" {...{\n          \"href\": \"#updating-our-test\",\n          \"aria-label\": \"updating our test permalink\",\n          \"className\": \"title-link before\"\n        }}><svg parentName=\"a\" {...{\n            \"width\": \"17\",\n            \"height\": \"18\",\n            \"viewBox\": \"0 0 17 18\",\n            \"fill\": \"none\",\n            \"xmlns\": \"http://www.w3.org/2000/svg\"\n          }}>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 6.33337H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 11.6666H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M6.75 1L5 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M12 1L10.25 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}</svg></a>{`Updating our test`}</h2><p parentName=\"section\">{`We're ready to update our test so that it uses our database. Wait though. Is there even something to change?\nNo, absolutely nothing. In fact, you can already try running Jest again and your test should pass. That's precisely the point of integration tests.`}</p><p parentName=\"section\">{`There's one thing we can do though. If you remember our previous test, the only part we couldn't test was whether or not the data had properly been persisted into the database.`}</p><p parentName=\"section\">{`Let's use the `}<inlineCode parentName=\"p\">{`ctx.app.db`}</inlineCode>{` property to fetch our database right after we've published the draft to ensure that it's been created by snapshotting the result.`}</p><pre parentName=\"section\"><code parentName=\"pre\" {...{\n          \"className\": \"language-diff\"\n        }}>{`// tests/Post.test.ts\n\nit('ensures that a draft can be created and published', async () => {\n  // ...\n\n  // Publish the previously created draft\n  const publishResult = await ctx.app.query(\n    \\`\n    mutation publishDraft($draftId: Int!) {\n      publish(draftId: $draftId) {\n        id\n        title\n        body\n        published\n      }\n    }\n  \\`,\n    { draftId: draftResult.createDraft.id }\n  )\n\n  // Snapshot the published draft and expect \\`published\\` to be true\n  expect(publishResult).toMatchInlineSnapshot(\\`\n    Object {\n      \"publish\": Object {\n        \"body\": \"...\",\n        \"id\": 1,\n        \"published\": true,\n        \"title\": \"Nexus\",\n      },\n    }\n  \\`)\n\n+ const persistedData = await ctx.app.db.client.post.findMany()\n\n+ expect(persistedData).toMatchInlineSnapshot()\n})\n`}</code></pre><p parentName=\"section\">{`The new snapshot should look like the following. It proves that our database did persist that data and that we have exactly one item in it.`}</p><pre parentName=\"section\"><code parentName=\"pre\" {...{\n          \"className\": \"language-diff\"\n        }}>{`expect(persistedData).toMatchInlineSnapshot(\\`\n+   Array [\n+     Object {\n+       \"body\": \"...\",\n+       \"id\": 1,\n+       \"published\": true,\n+       \"title\": \"Nexus\",\n+     },\n+   ]\n  \\`)\n`}</code></pre></section>\n    <section><h2 parentName=\"section\" {...{\n        \"id\": \"wrapping-up\",\n        \"style\": {\n          \"position\": \"relative\"\n        }\n      }}><a parentName=\"h2\" {...{\n          \"href\": \"#wrapping-up\",\n          \"aria-label\": \"wrapping up permalink\",\n          \"className\": \"title-link before\"\n        }}><svg parentName=\"a\" {...{\n            \"width\": \"17\",\n            \"height\": \"18\",\n            \"viewBox\": \"0 0 17 18\",\n            \"fill\": \"none\",\n            \"xmlns\": \"http://www.w3.org/2000/svg\"\n          }}>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 6.33337H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M1.5 11.6666H15.5\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M6.75 1L5 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}<path parentName=\"svg\" {...{\n              \"d\": \"M12 1L10.25 17\",\n              \"stroke\": \"#CBD5E0\",\n              \"strokeWidth\": \"2\",\n              \"strokeLineCap\": \"round\",\n              \"strokeLineJoin\": \"round\"\n            }}></path>{`\n      `}</svg></a>{`Wrapping up`}</h2><p parentName=\"section\">{`Congrats, you've performed your first real-world integration test. The fact that integration tests are completely decoupled from the implementation of your GraphQL API makes it a lot easier to maintain your test suite as you evolve your API. What matters is only the data that it produces, which also helps you cover your app a lot more than a single unit test.`}</p><p parentName=\"section\">{`About our app, it's starting to take shape but it's still lacking something pretty important in any application: authentication.`}</p><p parentName=\"section\">{`Come onto the next chapter to get that added to your app!`}</p><div class=\"NextIs NextChapter\"></div><p parentName=\"section\"><a parentName=\"p\" {...{\n          \"href\": \"/tutorial/chapter-7-authentication\"\n        }}>{`➳`}</a></p></section>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}